#' Parse inputs (from aracne-ap_viper Nextflow)
#' @param NETWORK ARACNe_AP network file
#' @param EXPRMAT expression matrix in tab-separated format:
#'                header line in format:
#'                geneID sample_1 ... sampleID_n
#'                all other lines in format
#'                geneID_1 value_1 ... value_n etc.
#' @param METADATA metadata to discriminate between cohorts for msViper analysis;
#'                 tab-separated format; header line format:
#'                 sample group
#'                 all other lines:
#'                 sampleID_1 group_0 etc.
#' @param genome_prefix string of a genome in biomart$dataset, suffixed with
#'                      '_gene_ensembl'
#' @param TAG string identifier of the run
#' @return none, saves two RData files to current dir contianing:
#'         ensembl to external gene mapping (en2ext);
#'         combined.eset, regulonaracne required to run msViper
#' @export

parse_aracne <- function(NETWORK, EXPRMAT, METADATA, TAG, genome_prefix = "hsapiens"){

  ##process annotation data
  tx2gene <- RNAseqon::get_tx2gene(genome_prefix)

  ##ARACNe regulon
  print("ARACNe-AP to regulon...")
  regulonaracne <- suppressWarnings(viper::aracne2regulon(afile = NETWORK,
                                                          eset = EXPRMAT))

  ## create eset
  print("Parsing expression matrix...")
  exprd <- readr::read_tsv(EXPRMAT)

  ##check geneID as external_gene_name, then convert to ensembl_gene_id
  exprdg <- dplyr::left_join(tx2gene, exprd) %>%
            dplyr::select(external_gene_name, ensembl_gene_id, where(is.numeric))

  exprdh <- highest_exp_wides(wide_object = exprdg,
                             name_col = "external_gene_name",
                             id_col = "ensembl_gene_id",
                             value_cols = 3:dim(exprdg)[2])

  print("Processing metadata...")
  pheno <- readr::read_tsv(METADATA)
  sumatch <- sum(match(colnames(pheno), c("sampleID", "group")))

  if(sumatch != 3 | is.na(sumatch)){
    print("Converting metadata colnames, ensure they are in sample, group order or msViper may fail!")
    colnames(pheno) <- c("sampleID", "group")
  }

  dot_dash <- ifelse(length(strsplit(colnames(exprd)[3], "-")[[1]]),"-", ".")
  phenodf <- pheno %>%
             dplyr::mutate(sampleID = gsub("-", dot_dash, sampleID)) %>%
             dplyr::filter(sampleID %in% colnames(exprd)) %>%
             dplyr::rename(description = group) %>%
             as.data.frame()
  exprds <- exprdh %>%
            dplyr::select(-external_gene_name) %>%
            as.data.frame() %>%
            tibble::column_to_rownames(., var = "ensembl_gene_id")
  phenos <- phenodf[phenodf$sampleID %in% colnames(exprds),]
  print("Creating ExpressionSet...")
  pData <- new("AnnotatedDataFrame",
                data=data.frame(row.names = colnames(exprds),
                                description = factor(phenos$description)))
  combined.eset <- Biobase::ExpressionSet(assayData = as.matrix(exprds),
                                          phenoData = pData)
  print("Saving...")
  save(combined.eset, tx2gene, phenos, exprds, exprdh, regulonaracne, file = paste0(TAG,".parse_inputs.RData"))
}

#' Run msViper
#' @param TAG string identifier of the run
#' @param RDATA RData file generated by parse_input()
#' @param genome_prefix string of a genome in biomart$dataset, suffixed with '_gene_ensembl'
#' @param msigdb_species one of msigdbr::msigdbr_show_species(), default:"Homo sapiens"
#' @param msigdb_cat one of 'c("H", paste0("C", c(1:7)))', see: gsea-msigdb.org/gsea/msigdb/collections.jsp
#' @param tag string used to prefix output
#' @param gene_col the name of the column in tibble with gene names found in pathways, set to "rownames" if they are the rownames (default)
#' @param output_dir path to where output goes
#' @param sig_val significance used in analysis
#' @param per_regulon flag to indicate if fgsea is at collective regulon level,
#'        or if each regulon and the genes it is co-expressed with are used
#' @return none, saves RData files of output
#' @export

run_msviper <- function(TAG, RDATA){

  ##load parse_input RData
  load(RDATA)

  ##generate signature for pairwise description levels
  LEVELS <- levels(factor(phenos$description))
  lapply(seq_along(LEVELS), function(f){

    level1 <- LEVELS[f]
    print(paste0("Working on: ", level1))

    ##require 10+ samples in Group
    if(table(phenos$description %in% level1)[2] > 7){
      pairname <- paste0(gsub(" ","-",level1), "_vs_rest")
      signature <- viper::rowTtest(combined.eset, "description", level1)
      rownamesp <- rownames(signature$p.value)
      signature$p.value <- as.matrix(p.adjust(signature$p.value, method="BH"))
      rownames(signature$p.value) <- rownamesp
      signature <- (qnorm(signature$p.value/2, lower.tail = FALSE) * sign(signature$statistic))[, 1]
      nullmodel <- viper::ttestNull(combined.eset, "description", level1, LEVELS[! LEVELS %in% level1], per = 5000, repos = TRUE, verbose = TRUE)

      ## msViper, leading edge analyses + bootstrapped
      mra <- viper::msviper(ges = signature,
                            regulon = regulonaracne,
                            nullmodel = nullmodel,
                            verbose = FALSE)
      mra <- viper::ledge(mra)
      mra <- viper::shadow(mobj = mra,
                           regulators = 0.01,
                           shadow = 0.01,
                           per = 5000,
                           verbose = FALSE)
      mrac <- viper::msviperCombinatorial(mobj = mra,
                                          regulators = 0.01,
                                          verbose = FALSE)

      ##if statement to deny error from synergy analysis which otherwise exits from the script
      if(length(mrac$regulon) > length(mra$regulon)){
        mra <- viper::msviperSynergy(mobj = mrac, verbose = FALSE)
        ##BH adjust p-values
        mra$es$q.value <- p.adjust(mra$es$p.value, method = "BH")
      }
      if(length(mrac$regulon) == length(mra$regulon)){
        ##BH adjust p-values
        mra$es$q.value <- p.adjust(mra$es$p.value, method = "BH")
      }

      ## outputs
      ##omit NaN as throws error
      mra$signature <- na.omit(mra$signature)
      pdf(paste0(TAG, ".", pairname, ".msViper.syn.results.pdf"))
        plot(mra, pval = mra$es$q.value, cex = .7)
      dev.off()

      mra_tb <- tibble::tibble(NES = mra$es$nes,
                               Size = mra$es$size,
                               p.value = mra$es$p.value,
                               q.value = mra$es$q.value)

      readr::write_tsv(tibble::as_tibble(mra_tb, rownames = "ensembl_gene_id"), file = paste0(TAG, ".", pairname, ".msViper.results.tsv"))

      retList <- list(mra, mra_tb)
      assignedName <- paste0(pairname)
      assign(assignedName, value = retList)
      saveFile <- paste0(TAG, ".", pairname, ".RData")
      save(list = assignedName, file = saveFile)

      ##fgsea ssgsea
      fgsea_ssgsea_msviper(mra = mra,
                           mra_stat = "p.value",
                           genome_prefix,
                           msigdb_species = "Homo sapiens",
                           msigdb_cat = "H",
                           TAG,
                           gene_col = "external_gene_name",
                           output_dir = "./",
                           sig_val = 0.1,
                           per_regulon = TRUE,
                           rdata = paste0(TAG, ".", pairname, ".RData"))

    }
  })
}

# ##filter out significant results (p-value)
# #'
# #' @param RDATA object
# #' @param ENS2EXT expression matrix in tab-separated format:
# #'                header line in format:
# #'                geneID sample_1 ... sampleID_n
# #'                all other lines in format
# #'                geneID_1 value_1 ... value_n etc.
# #' @param PVAL metadata to discriminate between cohorts for msViper analysis;
# #'                 tab-separated format; header line format:
# #'                 sample group
# #'                 all other lines:
# #'                 sampleID_1 group_0 etc.
# #' @return none, saves two RData files to current dir contianing:
# #'         ensembl to external gene mapping (en2ext);
# #'         combined.eset, regulonaracne required to run msViper
# #' @export
#
# filter_sig_res <- function(RDATA, ENS2EXT = "ens2ext.RData", PVAL = NULL){
#
#   ##load annotation
#   load(ENS2EXT)
#
#   if(is.null(PVAL)){
#     PVAL <- 0.05
#   }
#
#   for(x in 1:length(RDATA)){
#     print(paste0("Loading: ", RDATA[x]))
#     load(RDATA[x])
#   }
#
#   les <- ls(pattern="vs")
#   got <- get(les)
#   names(got) <- les
#   lapply(seq_along(got), function(ff){
#   f <- got[[ff]]
#   signames <- names(f$es$p.value[f$es$p.value<PVAL])
#   if(length(signames>0)){
#     sigout <- ens2ext %>% dplyr::filter(ensembl_gene_id %in% signames | external_gene_name %in% signames)
#     sigout$size <- f$es$size[names(f$es$size) %in% signames]
#     sigout$pvalue <- f$es$p.value[names(f$es$p.value) %in% signames]
#     sigout$qvalue <- f$es$q.value[names(f$es$q.value) %in% signames]
#     outname <- gsub("RData", "sig.tsv", grep("vs",RDATA,value=T)[ff])
#     write_tsv(sigout, path=outname)
#   }
#   if(length(signames==0)){
#     print(paste0("No significant genes found at p < ", PVAL))
#   }
#   })
# }

#'  The situation arises where a single gene name maps to multiple gene identifiers
#'  e.g. ENSG00000271503, ENSG00000274233 both map to CCL5
#'  this function takes wide format input with at least 3 rows:
#'  1: gene name
#'  2: gene identifier
#'  3: expression value(s) [can be index of columns]
#'  function returns a wide format object with highest expression name+id
#'  also returns full mapping info and mean expression value per name, id pairs
#'
#' @param wide_object a wide tibble or df
#' @param name_col naming column (gene name)
#' @param id_col identification column (gene ID, i.e. ENSID)
#' @param value_col expression value column (can be index)
#' @importFrom magrittr '%>%'
#' @return wide format with higehst exp. when multiple genes same named
#' @export

highest_exp_wides <- function(wide_object, name_col, id_col, value_cols){


  ##create mean_value of all rows, then count name_col
  ##filter out all with name_col single mapping
  mean_map <- wide_object %>% dplyr::select(name_col, id_col, value_cols) %>%
                              dplyr::mutate(mean_value = rowMeans(.[value_cols])) %>%
                              dplyr::group_by_at(dplyr::vars(name_col)) %>%
                              na.omit(mean_value) %>%
                              dplyr::add_count()%>%
                              dplyr::filter(n > 1) %>%
                              dplyr::filter(mean_value == max(mean_value)) %>%
                              dplyr::ungroup() %>%
                              dplyr::distinct_at(dplyr::vars(-id_col), .keep_all = TRUE) %>%
                              dplyr::select(-n, -mean_value)

  ##remove those with multi mapping (in mean_map) from original input
  #mean_map_o <- dplyr::anti_join(wide_object, mean_map, by = name_col) %>%

  ##return the two sets, bound
  #dplyr::bind_rows(mean_map_o, mean_map)
  return(mean_map)
}

#' Make required inputs for ARACNe-AP which is now supported through RNAseqon
#' @param tpm_tb tpms
#' @param metadata metadatas
#' @param meta_group metadatas group
#' @param tag string
#' @importFrom magrittr '%>%'
#' @return wide format with higehst exp. when multiple genes same named
#' @export

make_aracne_inputs <- function(tpm_tb, metadata, meta_group, tag){

  ##from *.de_ready.RData
  exprmat <- tpm_tb %>% dplyr::select(-external_gene_name)

  ##
  # regulators <- de_res %>% dplyr::select(ensembl_gene_id) %>%
  #                          as.data.frame()

  ##
  metaData <- metadata %>% dplyr::select(1, !!meta_group)

  readr::write_tsv(exprmat, file=paste0(tag, ".exprmat.tpm.tsv"))
  # readr::write_tsv(regulators, file=paste0(tag, ".regulators.txt"))
  readr::write_tsv(metaData, file=paste0(tag, ".metaData.txt"))
}

#' Run fgsea on each regulon set individually
#'
#' @param mra msviper class object with es, ledge
#' @param mra_stat statistic used to rank data, comes from msViper
#' @param genome_prefix string of a genome in biomart$dataset, suffixed with '_gene_ensembl'
#' @param msigdb_species one of msigdbr::msigdbr_show_species(), default:"Homo sapiens"
#' @param msigdb_cat one of 'c("H", paste0("C", c(1:7)))', see: gsea-msigdb.org/gsea/msigdb/collections.jsp
#' @param tag string used to prefix output
#' @param gene_col the name of the column in tibble with gene names found in pathways, set to "rownames" if they are the rownames (default)
#' @param output_dir path to where output goes
#' @param sig_val significance used in analysis
#' @param per_regulon flag to indicate if fgsea is at collective regulon level,
#'        or if each regulon and the genes it is co-expressed with are used
#' @param rdata parse_inputs.RData from parse_aracne() file location
#' @importFrom magrittr '%>%'
#' @return sure
#' @export

fgsea_ssgsea_msviper <- function(mra, mra_stat = "p.value", genome_prefix, msigdb_species = "Homo sapiens", msigdb_cat = "H", tag, gene_col = "external_gene_name", output_dir, sig_val = 0.1, per_regulon = NULL, rdata) {

  print("Running: fgsea_ssgsea_msviper()")

  ##output dir
  out_dir <- paste0(output_dir, "/viper")
  dir.create(paste0(out_dir, "/fgsea"), recursive = TRUE, showWarnings = FALSE)

  ##have to map ENS to ext AGAINNNN
  tx2gene <- RNAseqon::get_tx2gene(genome_prefix)

  ##MsigDB pathways genelists
  msigdb_pathlist <- msigdb_pathways_to_list(msigdb_species, msigdb_cat)

  ##create ranks
  if(is.null(per_regulon)){

    rank_vec <- tibble::as_tibble(data.frame(stat = mra$es[["nes"]]), rownames = gene_col) %>%
                dplyr::left_join(., tx2gene[,c(2,3)]) %>%
                dplyr::select(external_gene_name, stat) %>%
                dplyr::distinct() %>%
                na.omit() %>%
                tibble::deframe()

    ##run, order fgsea
    fgsea_res <- fgsea::fgsea(pathways = msigdb_pathlist,
                             stats = rank_vec,
                             nperm = 1000000)

    ##make tibble and add FDR, filters
    fgsea_res_tb <- dplyr::mutate(.data = tibble::as_tibble(fgsea_res))
    fgsea_res_sig_tb <- dplyr::filter(.data = fgsea_res_tb, padj < !!sig_val)
    fgsea_res_sig_tb <- dplyr::arrange(.data = fgsea_res_sig_tb, desc(NES))

    gg_fgsea <- fgsea_plot(fgsea_res_tb = fgsea_res_sig_tb, msigdb_cat = msigdb_cat)
    ggplot2::ggsave(gg_fgsea, file = paste0(out_dir, "/fgsea/", tag , ".fgsea_sig_viper.ggplot2.pdf"))
    save(fgsea_res_tb, file = paste0(out_dir, "/fgsea/", tag , ".fgsea_sig_viper.RData"))

  } else {

    ##get those sweet rotation ssGSEA  plots
    sigulons <- names(mra$regulon)[mra$es$p.value < sig_val]
    sigunames <- dplyr::filter(.data = dplyr::distinct(tx2gene[,c(2,3)]), ensembl_gene_id %in% sigulons)
    sigunames <- c(dplyr::select(.data = sigunames, external_gene_name))

    fgsea_res_sigulon_list <- lapply(sigulons, function(f){
      tfmode <- mra$regulon[[f]]$tfmode
      rank_vec <- tibble::as_tibble(tfmode, rownames = "ensembl_gene_id") %>%
                  dplyr::left_join(., dplyr::distinct(tx2gene[,c(2,3)])) %>%
                  dplyr::select(external_gene_name, stat = "value") %>%
                  dplyr::distinct() %>%
                  na.omit() %>%
                  tibble::deframe()

      ##run, order fgsea
      fgsea_res <- fgsea::fgsea(pathways = msigdb_pathlist,
                               stats = rank_vec,
                               nperm = 1000000)

      ##make tibble and add FDR, filters
      fgsea_res_tb <- dplyr::mutate(.data = tibble::as_tibble(fgsea_res))
      fgsea_res_sig_tb <- dplyr::filter(.data = fgsea_res_tb, padj < !!sig_val)

      if(dim(fgsea_res_sig_tb)[1] > 0){

        gg_fgsea <- fgsea_plot(fgsea_res_tb = fgsea_res_sig_tb, msigdb_cat = msigdb_cat)
      #  ggplot2::ggsave(gg_fgsea, file = paste0(out_dir, "/plots/", tag , ".fgsea_sig_viper.ggplot2.pdf"))
        save(fgsea_res_tb, gg_fgsea, file = paste0(out_dir, "/fgsea/", tag , ".fgsea_sig_viper.RData"))
      }

      return(names(rank_vec))

    })

    names(fgsea_res_sigulon_list) <- unlist(sigunames)

    save(fgsea_res_sigulon_list, file = paste0(out_dir, "/fgsea/", tag , ".per_regulon_viper.RData"))

    ##do ssgsea
    add_small <- function(f){f+0.0000001}
    log2_tpm_mat <- dplyr::mutate(.data = exprdh, dplyr::across(where(is.numeric), add_small)) %>%
                    dplyr::mutate(dplyr::across(where(is.numeric), log2)) %>%
                    dplyr::select(-ensembl_gene_id) %>%
                    dplyr::distinct() %>%
                    tibble::column_to_rownames("external_gene_name") %>%
                    as.matrix()

    metadata <- phenos %>% dplyr::rename(sample = "sampleID", group = "description")
    ssgsea_pca_list <- RNAseqon::ssgsea_pca(pways = fgsea_res_sigulon_list,
                                  log2tpm_mat = log2_tpm_mat,
                                  msigdb_cat = "H",
                                  output_dir = out_dir,
                                  contrast = "msViper Regulon Genesets",
                                  metadata = metadata)
    names(ssgsea_pca_list) <- sigunames
    save(ssgsea_pca_list, file = paste0(out_dir, "/ssgsea/", tag , ".ssgsea_pca_viper.RData"))

  }
}
